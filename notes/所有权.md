# 所有权

## 堆栈知识

### 内存区域

> 所有在编译器已知固定大小的数据可以存放在栈内存中。反之，这些数据只能存储在堆内存中。

### 堆内存分配

> 当我需要将数据放入堆内存中时，需要向操作系统申请空间。操作系统会寻找一块足够大的空间，标记为已使用，并将地址指针返回给我。这个就是所谓的堆分配过程。操作系统需要及时清理无用数据以避免空间浪费。

## 所有权原则

> - Rust中每一个值都有一个对应的变量作为他的所有者。
> - 在同一时间内，值有且仅有一个所有者(所有者可以更换,但是不能有多个)。
> - 当所有者离自己的作用域时，它持有的值就会被释放掉(值与所有者共存亡)。

### 理解

1. 变量从声明开始生效，到其作用域结束失效。同时其所有的值也会被清理（栈内存数据出栈，堆内存数据会被申请释放）

```rust
    {

        let s : String  = String::from("hello world"); //S开始生效

    }   //离开作用域。S失效，堆内存上的String数据“hello world"也会被销毁
```

2. Rust会在堆内存变量离开其作用域时调用drop函数，将其内存空间释放。而对于栈内存数据，在其离开作用域时并不会发生销毁。

## 所有权转移(move)

> 如果给一个堆内存数据指定两个指针，Rust会直接将数据的所有权转移到后一个指针上，第一个指针随之失效。此时数据的所有权发生了转移(move)。
>
> 变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量是就会发生所有权转移。这条规则适用于赋值，同样也适用于函数的参数和返回值。

### 理解

1. 所有权转移可以防止发生，同一块内存区域重复释放两次的BUG

```rust
    fn main(){
        let mut s = String::from("hello");  //数据绑定到s上
        let s1 = s;  //数据所有权转移到s1
        s.push_str(",world"); //错误，s已经失效所以无法操作
        s = String::from("world")//但是此处可以将s重新绑定数据
    } //s1离开作用域，数据释放。由于s之前已经无效，所以不会发生重复释放问题
```

2.数据作为参数传入函数和作为返回值时，也会发生所有权转移

```rust
    fn move_to_fn(s:String)->String{
        println!("{}",s.len());
        s
    } // s所绑定的数据返回，数据所有权转移到调用函数

    fn main(){
        let s = String::from("hello");

        let s1 = move_to_fn(s);  //s绑定数据的所有权转移到函数中

        s.push_str(",world"); //错误，s已经失效无法调用

    }
```
## 引用和借用(borrow)

### 深拷贝和浅拷贝

两种拷贝区别在于拷贝堆内存数据时

- 浅拷贝只拷贝堆内存的栈上指针，例如java的传参、rust的借用传参。这样就造成了多个指针指向同一个数据的局面。
- 深拷贝是直接复制一份指针+堆数据的组合，在rust中需要调用<code>.clone()</code>方法。在堆内存数据很大的情况下，这是一种相当消耗资源的行为

### 使用场景

在函数调用完毕之后，如果我们还想使用传入的参数，需要一种新的所有权分配方式才可以避免值传入函数之后所有权丢失的问题。这种新的方式就是借用，有点像C语言的指针，不转移所有权。

```rust
    fn move_to_fn(s:&String){ //此处的变量s叫做引用，此种所有权分配方式叫做借用
        println!("{}",s.len()); 
    }  //此处没有发生所有权转移，所以函数调用完毕后我们可以继续使用传入的变量
```

