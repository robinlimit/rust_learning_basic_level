# 所有权

## 堆栈知识

### 内存区域

> 所有在编译器已知固定大小的数据可以存放在栈内存中。反之，这些数据只能存储在堆内存中。

### 堆内存分配

> 当我需要将数据放入堆内存中时，需要向操作系统申请空间。操作系统会寻找一块足够大的空间，标记为已使用，并将地址指针返回给我。这个就是所谓的堆分配过程。操作系统需要及时清理无用数据以避免空间浪费。

## 所有权原则

> - Rust中每一个值都有一个对应的变量作为他的所有者。
> - 在同一时间内，值有且仅有一个所有者(所有者可以更换,但是不能有多个)。
> - 当所有者离自己的作用域时，它持有的值就会被释放掉(值与所有者共存亡)。

### 理解

1. 变量从声明开始生效，到其作用域结束失效。同时其所有的值也会被清理（栈内存数据出栈，堆内存数据会被申请释放）

```rust
    {

        let s : String  = String::from("hello world"); //S开始生效

    }   //离开作用域。S失效，堆内存上的String数据“hello world"也会被销毁
```

2. Rust会在堆内存变量离开其作用域时调用drop函数，将其内存空间释放。而对于栈内存数据，在其离开作用域时并不会发生销毁。

## 所有权转移(move)

> 如果给一个堆内存数据指定两个指针，Rust会直接将数据的所有权转移到后一个指针上，第一个指针随之失效。此时数据的所有权发生了转移(move)。
>
> 变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量是就会发生所有权转移。这条规则适用于赋值，同样也适用于函数的参数和返回值。

### 理解

1. 所有权转移可以防止发生，同一块内存区域重复释放两次的BUG

```rust
    fn main(){
        let mut s = String::from("hello");  //数据绑定到s上
        let s1 = s;  //数据所有权转移到s1
        s.push_str(",world"); //错误，s已经失效所以无法操作
        s = String::from("world")//但是此处可以将s重新绑定数据
    } //s1离开作用域，数据释放。由于s之前已经无效，所以不会发生重复释放问题
```

2.数据作为参数传入函数和作为返回值时，也会发生所有权转移

```rust
    fn move_to_fn(s:String)->String{
        println!("{}",s.len());
        s
    } // s所绑定的数据返回，数据所有权转移到调用函数

    fn main(){
        let s = String::from("hello");

        let s1 = move_to_fn(s);  //s绑定数据的所有权转移到函数中

        s.push_str(",world"); //错误，s已经失效无法调用

    }
```
