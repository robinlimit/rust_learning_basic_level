# 所有权

## 堆栈知识

### 内存区域

> 所有在编译器已知固定大小的数据可以存放在栈内存中。反之，这些数据只能存储在堆内存中。

### 堆内存分配

> 当我需要将数据放入堆内存中时，需要向操作系统申请空间。操作系统会寻找一块足够大的空间，标记为已使用，并将地址指针返回给我。这个就是所谓的堆分配过程。操作系统需要及时清理无用数据以避免空间浪费。

## 所有权原则

> - Rust中每一个值都有一个对应的变量作为他的所有者。
> - 在同一时间内，值有且仅有一个所有者(所有者可以更换,但是不能有多个)。
> - 当所有者离自己的作用域时，它持有的值就会被释放掉(值与所有者共存亡)。

### 理解

1. 变量从声明开始生效，到其作用域结束失效。同时其所有的值也会被清理（栈内存数据出栈，堆内存数据会被申请释放）

```rust
    {

        let s : String  = String::from("hello world"); //S开始生效

    }   //离开作用域。S失效，堆内存上的String数据“hello world"也会被销毁
```

2. Rust会在堆内存变量离开其作用域时调用drop函数，将其内存空间释放。而对于栈内存数据，在其离开作用域时并不会发生销毁。

## 所有权转移(move)

> 如果给一个堆内存数据指定两个指针，Rust会直接将数据的所有权转移到后一个指针上，第一个指针随之失效。此时数据的所有权发生了转移(move)。
>
> 变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量是就会发生所有权转移。这条规则适用于赋值，同样也适用于函数的参数和返回值。

### 理解

1. 所有权转移可以防止发生，同一块内存区域重复释放两次的BUG

```rust
    fn main(){
        let mut s = String::from("hello");  //数据绑定到s上
        let s1 = s;  //数据所有权转移到s1
        s.push_str(",world"); //错误，s已经失效所以无法操作
        s = String::from("world")//但是此处可以将s重新绑定数据
    } //s1离开作用域，数据释放。由于s之前已经无效，所以不会发生重复释放问题
```

2.数据作为参数传入函数和作为返回值时，也会发生所有权转移

```rust
    fn move_to_fn(s:String)->String{
        println!("{}",s.len());
        s
    } // s所绑定的数据返回，数据所有权转移到调用函数

    fn main(){
        let s = String::from("hello");

        let s1 = move_to_fn(s);  //s绑定数据的所有权转移到函数中

        s.push_str(",world"); //错误，s已经失效无法调用

    }
```
## 引用和借用(borrow)

### 深拷贝和浅拷贝

两种拷贝区别在于拷贝堆内存数据时

- 浅拷贝只拷贝堆内存的栈上指针，例如java的传参、rust的借用传参。这样就造成了多个指针指向同一个数据的局面。
- 深拷贝是直接复制一份指针+堆数据的组合，在rust中需要调用<code>.clone()</code>方法。在堆内存数据很大的情况下，这是一种相当消耗资源的行为

### 使用场景

在函数调用完毕之后，如果我们还想使用传入的参数，需要一种新的所有权分配方式才可以避免值传入函数之后所有权丢失的问题。这种新的方式就是借用，有点像C语言的指针，不转移所有权。

```rust
    fn move_to_fn(s:&String){ //此处的变量s叫做引用，此种所有权分配方式叫做借用
        println!("{}",s.len()); 
    }  //此处没有发生所有权转移，所以函数调用完毕后我们可以继续使用传入的变量
```
### 借用(borrow &)的本质

当借用发生时，实际上产生了一个指向胖指针的引用，造成了引用指向胖指针引，然后胖指针指向数据的局面。

![borrow](pic/borrow.png)

### Rust如何处理多个只读引用

> Rust使用复制策略处理多个只读引用，所以当函数参数为引用时，Rust是直接传值的，传入的是引用的复制体。

下面使用例子说明，注意其中三个引用的地址各不相同。

这个例子同时也解释了{:p}这个格式化字符串的用法。

```rust
fn main() {
    let s = vec![1, 2, 3, 4];
    let s1 = &s;
    /*
    打印数据的内存地址可以使用下面的语法
    注意：
    - 使用格式化字符串{:p}可以输出指针中存储的内存地址
    - 所以如果需要知打印某个数据的地址,先使用&符号构建它的引用,然后打印这个引用的{:p}即可
    - Rust中实现了Pointer Trait的数据结构均可使用{:p}打印
    */
    println!(
        "Addr of s(s1): {:p}({:p}), Addr of &s: {:p}, Addr of s1: {:p}",
        &s, s1, &&s, &s1
    );
    println!("sum of s: {}", sum(s1));
}

fn sum(data: &Vec<i32>) -> i32 {
    println!("addr of data: {:p}, addr of &data: {:p}", data, &data);
    data.iter().fold(0, |acc, x| acc + x)
}
/*
打印&s显示的是s的地址,s1等于s,它们都指向s所以地址相同
Addr of s(s1): 0xe829dff7f8(0xe829dff7f8), 
这行打印的是&s这个引用的地址
Addr of &s: 0xe829dff898, 
这行打印的是s1的地址,可以发现虽然都是s的引用但是它们地址不同。
说明Rust对于多个只读引用使用的策略是直接复制。
Addr of s1: 0xe829dff810
这行打印的是参数data指向的地址,data也指向s所以地址相同
addr of data: 0xe829dff7f8, 
这行打印的是data这个指针的地址,可以发现3个指向s的指针,本身的地址都不相同。
addr of &data: 0xe829dff6c8
sum of s: 10
 */
```

### 防止“使用已释放内存”

由于引用与数据不会被同时销毁，一旦数据离开作用域被释放。如何避免继续使用引用操作已被释放的内存？
Rust对于引用进行了约束，即引用的生命周期不能超过数据本身，编译器会严格进行生命周期检查。

```rust
///这块代码无法编译
fn main(){
    let t = local_ref();
    println!("r: {:p}",r)
}

fn local_ref<'a>() -> &'a i32{
    let a = 43;
    &a
}
```


